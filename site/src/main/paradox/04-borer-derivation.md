`borer-derivation`
==================

When you include the `borer-derivation` module as a dependency (see the @ref:[Getting Started](02-getting-started.md)
chapter for details) _borer_ can (semi-automatically) provide encoders and decoders for case classes and ADTs by
deriving them with the help of a macro (which is heavily inspired by [Magnolia]).

There are two basic alternatives to choose from:

- @ref:[Array-Based Codecs](#array-based-codecs) or
- @ref:[Map-Based Codecs](#map-based-codecs).


Array-Based Codecs
------------------

Array-Based Codec derivation is enabled with this import:

@@snip [-]($test$/DerivationSpec.scala) { #import-array-based }

This brings the three methods `deriveEncoder[T]`, `deriveDecoder[T]` and `deriveCodec[T]` in scope,
which you can use to derive the respective type classes for case classes and ADTs.

Here is an example:

@@snip [-]($test$/DerivationSpec.scala) { #array-based }   

With these codecs case classes are written to [CBOR]/[JSON] as simple arrays, unless the case class has arity 1.
If the case class has only a single member, the derived codec directly writes the member without wrapping it in an
array.  

An Abstract Data Type (ADT) is encoded as an array of length two, with the first element holding the type ID and
the second holding the instance's encoding (i.e. an array or single element).

The type ID is required to enable the decoder to determine which ADT sub-type to decode into.<br>
By default _borer_ will use type's short class name as a (textual) type ID.
If you want to customize this you can use the `@key` annotation to do so.
Check out the `@key` sources @github[here](/derivation/src/main/scala/io/bullet/borer/derivation/key.scala) for more info.


Map-Based Codecs
----------------

Map-based codec derivation is enabled with this import:

@@snip [-]($test$/DerivationSpec.scala) { #import-map-based }

With these codecs case classes are encoded as [CBOR]/[JSON] maps with the member name as key, i.e. in the same way that
you would normally expect a [JSON] codec to do it. 

ADTs are encoded as single-entry maps, with the key being the type id (`@key` or simple class name) and the value
becoming the encoding of the actual ADT subtype instance.

Here is the example from above with map-based codecs:

@@snip [-]($test$/DerivationSpec.scala) { #map-based }


### Default Values

Map-based codecs support missing and extra members. Extra members (i.e. map keys present in the encoding but not defined
as a case class member or `@key`) are simply ignored.<br>
For missing members the type's `Decoder` will use the potentially defined default value, e.g.:

@@snip [-]($test$/DerivationSpec.scala) { #default-value } 

Also, `Encoder`/`Decoder` type classes can implement the `Encoder.DefaultValueAware` / `Decoder.DefaultValueAware`
trait in order to alter their behavior in the presence of a default value.

This is used, for example, by the pre-defined encoder and decoder for `Option[T]`, which change their encoding/decoding
strategy, if a `None` default value is defined for a case class member. In this case the optional value will only be
written if it's defined (and then without any wrapping structure). If the option is undefined nothing is written at all.

Here is the actual implementation of _borer_'s `Encoder` for `Option`:

@@snip [-]($core$/Encoder.scala) { #option-encoder }


Correspondingly, during decoding the presence of the member yields a defined option instance holding the decoded value
and `None`, if the member is missing.

This behavior should match the intution of what an `Option[T]` case class member would behave like when written to a
[JSON] representation. 


### Customized Member Keys

_borer_ supports customizing the name of case class members in the encoding with the same `@key` annotation, that is
also used for custom ADT type-ids (see @ref:[above](#array-based-codecs) and the `@key` sources
@github[here](/derivation/src/main/scala/io/bullet/borer/derivation/key.scala) for more info).

Simply annotate a case class member do provide a custom name:

@@snip [-]($test$/DerivationSpec.scala) { #custom-member-name }


Semi- vs. Fully-automatic Derivation
------------------------------------

Currently, _borer_'s codec derivation machinery is intentionally not fully automatic, i.e. codecs are never created
implicitly but require you to write one line per type. The best-practice here is to cache the created codec in an
`implicit val` or `implicit lazy val` (in case there are circular dependencies between the types).

This semi-automatic derivation has a few important benefits over fully-automatic derivation (where you would only have
to write one line per ADT super type):

1. It makes derivation much more predictable as the code that is generated by the derivation macro will never be
   unexpectedly large. The derived codec logic will only ever concern itself with how to encode/decode instances of
   the type `T` that the `deriveEncoder[T]`, `deriveDecoder[T]` or `deriveCodec[T]` macro is parameterized with.<br>
   It'll never deal with member types or sub types.
   
2. Debugging and customization become a lot easier. Errors (like missing implicit encoders/decoders) will be reported
   exactly at the right line (type) and mixing encoding approaches or configurations for the different sub-types of an
   ADT is never a problem.

3. The macro code is _a lot_ simpler and thus easier to write and maintain.
   Proper fully-automatic derivation must be able to deal with direct and indirect recursion, properly cache and re-use
   intermediate derivations and provide deep and accurate error messages.   
    
For these reasons borer currently does not implement fully-automatic derivation.


  [CBOR]: http://cbor.io/
  [JSON]: http://json.org/
  [Magnolia]: https://propensive.com/opensource/magnolia