Semi- vs. Fully-automatic Derivation
====================================

Currently, _borer_'s codec derivation machinery is intentionally not fully automatic, i.e. codecs are never created
implicitly but require you to write one line per type. The best-practice here is to cache the created codec in an
`implicit val` or `implicit lazy val` (in case there are circular dependencies between the types).

This semi-automatic derivation has a few important benefits over fully-automatic derivation (where you would only have
to write one line per ADT super type):

1. It makes derivation much more predictable as the code that is generated by the derivation macro will never be
   unexpectedly large. The derived codec logic will only ever concern itself with how to encode/decode instances of
   the type `T` that the `deriveEncoder[T]`, `deriveDecoder[T]` or `deriveCodec[T]` macro is parameterized with.<br>
   It'll never deal with member types or sub types.
   
2. Debugging and customization become a lot easier. Errors (like missing implicit encoders/decoders) will be reported
   exactly at the right line (type) and mixing encoding approaches or configurations for the different sub-types of an
   ADT is never a problem.

3. The macro code is _a lot_ simpler and thus easier to write and maintain.
   Proper fully-automatic derivation must be able to deal with direct and indirect recursion, properly cache and re-use
   intermediate derivations and provide deep and accurate error messages.   
    
For these reasons borer currently does not implement fully-automatic derivation.